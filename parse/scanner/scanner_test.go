package scanner_test

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/jBugman/fun-lang/fun/tokens"
	"github.com/jBugman/fun-lang/parse/scanner"
)

// stateless helper
func scan(text string) (tokens.Token, string, *scanner.Scanner) {
	s := scanner.NewScanner(strings.NewReader(text))
	tok, txt := s.Scan()
	return tok, txt, s
}

func TestScanner_Scan_empty(t *testing.T) {
	tok, txt, s := scan("")
	assert.Equal(t, tokens.EOF, tok)
	assert.Empty(t, txt)
	assert.Equal(t, 0, s.N)
}

func TestScanner_Scan_longWhitespace(t *testing.T) {
	tok, txt, s := scan("     	  	 ")
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, txt, " ")
	assert.Equal(t, 10, s.N)
}

func TestScanner_Scan_integer(t *testing.T) {
	tok, txt, s := scan("42")
	assert.Equal(t, tokens.INTEGER, tok)
	assert.Equal(t, "42", txt)
	assert.Equal(t, 2, s.N)
}

func TestScanner_Scan_twoIntegers(t *testing.T) {
	tok, txt, s := scan("123 45")
	assert.Equal(t, tokens.INTEGER, tok)
	assert.Equal(t, "123", txt)
	assert.Equal(t, 3, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, " ", txt)
	assert.Equal(t, 4, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.INTEGER, tok)
	assert.Equal(t, "45", txt)
	assert.Equal(t, 6, s.N)
}

func TestScanner_Scan_Float(t *testing.T) {
	tok, txt, s := scan("36.6")
	assert.Equal(t, tokens.FLOAT, tok)
	assert.Equal(t, "36.6", txt)
	assert.Equal(t, 4, s.N)
}

func TestScanner_Scan_fakeNumber(t *testing.T) {
	tok, txt, s := scan("99bottles")
	assert.Equal(t, tokens.INTEGER, tok)
	assert.Equal(t, "99", txt)
	assert.Equal(t, 2, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "bottles", txt)
	assert.Equal(t, 9, s.N)
}

func TestScanner_Scan_words(t *testing.T) {
	tok, txt, s := scan("some words ")
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "some", txt)
	assert.Equal(t, 4, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, " ", txt)
	assert.Equal(t, 5, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "words", txt)
	assert.Equal(t, 10, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, " ", txt)
	assert.Equal(t, 11, s.N)
}

func TestScanner_Scan_moduleDeclaration(t *testing.T) {
	tok, txt, s := scan("module Main where\n")
	assert.Equal(t, tokens.MODULE, tok)
	assert.Equal(t, "module", txt)
	assert.Equal(t, 6, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, " ", txt)
	assert.Equal(t, 7, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "Main", txt)
	assert.Equal(t, 11, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, " ", txt)
	assert.Equal(t, 12, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WHERE, tok)
	assert.Equal(t, "where", txt)
	assert.Equal(t, 17, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, "\n", txt)
	assert.Equal(t, 18, s.N)
}

func TestScanner_Scan_Arrow(t *testing.T) {
	tok, txt, s := scan("->")
	assert.Equal(t, tokens.ARROW, tok)
	assert.Equal(t, "->", txt)
	assert.Equal(t, 2, s.N)
}

func TestScanner_Scan_braces(t *testing.T) {
	tok, txt, s := scan("(())")
	assert.Equal(t, tokens.OPENBR, tok)
	assert.Equal(t, "(", txt)
	assert.Equal(t, 1, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.UNIT, tok)
	assert.Equal(t, "()", txt)
	assert.Equal(t, 3, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.CLOSEBR, tok)
	assert.Equal(t, ")", txt)
	assert.Equal(t, 4, s.N)
}

func TestScanner_Scan_funcDecl(t *testing.T) {
	tok, txt, s := scan("f :: int -> IO ()\nf x = undefined")
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "f", txt)
	assert.Equal(t, 1, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 2, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.DOUBLECOLON, tok)
	assert.Equal(t, "::", txt)
	assert.Equal(t, 4, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 5, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "int", txt)
	assert.Equal(t, 8, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 9, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.ARROW, tok)
	assert.Equal(t, 11, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 12, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IO, tok)
	assert.Equal(t, "IO", txt)
	assert.Equal(t, 14, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 15, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.UNIT, tok)
	assert.Equal(t, 17, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 18, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "f", txt)
	assert.Equal(t, 19, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 20, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "x", txt)
	assert.Equal(t, 21, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 22, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.EQ, tok)
	assert.Equal(t, "=", txt)
	assert.Equal(t, 23, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 24, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.UNDEFINED, tok)
	assert.Equal(t, "undefined", txt)
	assert.Equal(t, 33, s.N)
}

func TestScanner_Scan_import(t *testing.T) {
	tok, txt, s := scan(`import "log15" as "log"`)
	assert.Equal(t, tokens.IMPORT, tok)
	assert.Equal(t, "import", txt)
	assert.Equal(t, 6, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 7, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, "\"", txt)
	assert.Equal(t, 8, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "log15", txt)
	assert.Equal(t, 13, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 14, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 15, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.AS, tok)
	assert.Equal(t, "as", txt)
	assert.Equal(t, 17, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 18, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 19, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "log", txt)
	assert.Equal(t, 22, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 23, s.N)
}

func TestScanner_Scan_42(t *testing.T) {
	tok, txt, s := scan("42\n")
	assert.Equal(t, tokens.INTEGER, tok)
	assert.Equal(t, "42", txt)
	assert.Equal(t, 2, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 3, s.N)
}

func TestScanner_Scan_module(t *testing.T) {
	tok, txt, s := scan(ex(`
	module Main where

	import "fmt"
	import "io" as "io"

	inc :: int -> int
	inc val = val + 1
	`))
	// Line 1
	assert.Equal(t, tokens.MODULE, tok)
	assert.Equal(t, "module", txt)
	assert.Equal(t, 6, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 7, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "Main", txt)
	assert.Equal(t, 11, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 12, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.WHERE, tok)
	assert.Equal(t, "where", txt)
	assert.Equal(t, 17, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 18, s.N)
	// Line 2
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 19, s.N)
	// Line 3
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IMPORT, tok)
	assert.Equal(t, "import", txt)
	assert.Equal(t, 25, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 26, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 27, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "fmt", txt)
	assert.Equal(t, 30, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 31, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 32, s.N)
	// Line 4
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IMPORT, tok)
	assert.Equal(t, "import", txt)
	assert.Equal(t, 38, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 39, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 40, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "io", txt)
	assert.Equal(t, 42, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 43, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 44, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.AS, tok)
	assert.Equal(t, "as", txt)
	assert.Equal(t, 46, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 47, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 48, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "io", txt)
	assert.Equal(t, 50, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.QUOTE, tok)
	assert.Equal(t, 51, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 52, s.N)
	// Line 5
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 53, s.N)
	// Line 6
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "inc", txt)
	assert.Equal(t, 56, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 57, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.DOUBLECOLON, tok)
	assert.Equal(t, "::", txt)
	assert.Equal(t, 59, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 60, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "int", txt)
	assert.Equal(t, 63, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 64, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.ARROW, tok)
	assert.Equal(t, "->", txt)
	assert.Equal(t, 66, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 67, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "int", txt)
	assert.Equal(t, 70, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.LF, tok)
	assert.Equal(t, 71, s.N)
	// Line 7
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "inc", txt)
	assert.Equal(t, 74, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 75, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "val", txt)
	assert.Equal(t, 78, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 79, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.EQ, tok)
	assert.Equal(t, "=", txt)
	assert.Equal(t, 80, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 81, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.IDENT, tok)
	assert.Equal(t, "val", txt)
	assert.Equal(t, 84, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 85, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.PLUS, tok)
	assert.Equal(t, "+", txt)
	assert.Equal(t, 86, s.N)
	tok, _ = s.Scan()
	assert.Equal(t, tokens.WS, tok)
	assert.Equal(t, 87, s.N)
	tok, txt = s.Scan()
	assert.Equal(t, tokens.INTEGER, tok)
	assert.Equal(t, "1", txt)
	assert.Equal(t, 88, s.N)
}

func ex(source string) string {
	lines := strings.Split(strings.TrimSpace(source), "\n")
	for i := 0; i < len(lines); i++ {
		lines[i] = strings.TrimPrefix(lines[i], "\t")
	}
	return strings.Join(lines, "\n")
}
